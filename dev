#!/bin/bash
# Medical AI Development Environment Startup
#
# ═══════════════════════════════════════════════════════════════════════════
# SINGLE CONSOLIDATED ENTRY POINT FOR OPERATOR EXTENSION
# ═══════════════════════════════════════════════════════════════════════════
#
# This is the ONLY script you need to run to start the complete development
# environment. All other startup scripts have been deprecated or are called
# automatically by this script.
#
# SERVICES STARTED:
# ─────────────────────────────────────────────────────────────────────────────
# 1. LMStudio Server (localhost:1234)
#    - Interactive model selection for Reasoning + Quick models
#    - Parallel model loading for faster startup
#    - Automatic health checking and retry logic
#
# 2. Transcription Server (localhost:8001)
#    - MLX Whisper (default, fast) or Google MedASR (medical vocab testing)
#    - Python virtual environment management (venv-whisper / venv-medasr)
#    - Automatic dependency installation
#    - Runs in background without macOS dock appearance
#    - Called via: ./start-whisper-server.sh or ./start-medasr-server.sh
#
# 3. DSPy Server (localhost:8002)
#    - Prompt optimization and evaluation server
#    - LM Studio SDK integration for streaming
#    - PID-based lifecycle management
#    - Called via: ./start-dspy-server.sh
#
# 4. Operator Ingest Daemon (macOS menubar app)
#    - Processes mobile/Shortcut audio ingestion
#    - Python virtual environment (mac_daemon/.venv-ingest)
#    - Runs via: python -m mac_daemon.main
#
# 5. Ward Round Watcher (TypeScript)
#    - Monitors ward round data changes
#    - Runs via: npm run wardround:watch
#
# USAGE:
# ─────────────────────────────────────────────────────────────────────────────
#   ./dev              # Start all services (interactive model selection)
#   ./dev --status     # Check service health without starting
#   ./dev --help       # Show help message
#
# DEPENDENCIES:
# ─────────────────────────────────────────────────────────────────────────────
# - LM Studio CLI (lms) - Install: https://lmstudio.ai/docs/cli
# - Python 3.8+ - For transcription and DSPy servers
# - Node.js & npm - For TypeScript ward round watcher
# - ffmpeg - For audio conversion (brew install ffmpeg)
#
# INDIVIDUAL SERVICE MANAGEMENT:
# ─────────────────────────────────────────────────────────────────────────────
# If you need to manage services individually:
#   ./start-whisper-server.sh        # Start MLX Whisper only
#   ./start-medasr-server.sh         # Start Google MedASR only
#   ./start-dspy-server.sh start     # Start DSPy only
#   ./start-dspy-server.sh stop      # Stop DSPy
#   ./start-dspy-server.sh restart   # Restart DSPy
#   ./start-dspy-server.sh logs      # View DSPy logs
#
# Or via npm scripts:
#   npm run dev:start                # Same as ./dev
#   npm run dspy:server:start        # Start DSPy only
#   npm run dspy:server:stop         # Stop DSPy only
#   npm run dspy:server:logs         # View DSPy logs
#
# TROUBLESHOOTING:
# ─────────────────────────────────────────────────────────────────────────────
# Port conflicts:
#   lsof -i :1234  # Check what's using LMStudio port
#   lsof -i :8001  # Check what's using Transcription port
#   lsof -i :8002  # Check what's using DSPy port
#
# Service health checks:
#   curl http://localhost:1234/v1/models  # LMStudio
#   curl http://localhost:8001/v1/health  # Transcription
#   curl http://localhost:8002/v1/health  # DSPy
#
# Reset virtual environments:
#   rm -rf venv-whisper venv-medasr dspy-env mac_daemon/.venv-ingest
#   ./dev  # Will recreate environments
#
# ═══════════════════════════════════════════════════════════════════════════
# Note: set -e removed to allow graceful degradation when services fail
# Each service failure is handled explicitly to allow partial success
# ═══════════════════════════════════════════════════════════════════════════

# macOS-compatible timeout function
run_with_timeout() {
    local timeout_duration=$1
    shift

    # Use gtimeout if available (from coreutils), otherwise use built-in timeout if available
    if command -v gtimeout >/dev/null 2>&1; then
        gtimeout "$timeout_duration" "$@"
    elif command -v timeout >/dev/null 2>&1; then
        timeout "$timeout_duration" "$@"
    else
        # Fallback: run without timeout on macOS
        "$@"
    fi
}

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

section() {
    echo
    echo -e "${BOLD}$1${NC}"
}

log() {
    echo -e "${DIM}  $1${NC}"
}

warn() {
    echo -e "${YELLOW}[!]${NC} $1"
}

error() {
    echo -e "${RED}[x]${NC} $1"
}

info() {
    echo -e "${BLUE}[i]${NC} $1"
}

success() {
    echo -e "${GREEN}[ok]${NC} $1"
}

clear_line() {
    local cols
    cols=$(tput cols 2>/dev/null || echo 80)
    printf "\r%*s\r" "$cols" ""
}

start_progress_bar() {
    local label="$1"
    local total="$2"
    local width="${3:-24}"

    PROGRESS_PID=""
    if [ ! -t 1 ]; then
        return 0
    fi

    (
        local start
        start=$(date +%s)
        while true; do
            local now elapsed percent filled empty filled_bar empty_bar mins secs
            now=$(date +%s)
            elapsed=$((now - start))
            if [ "$total" -gt 0 ] && [ "$elapsed" -gt "$total" ]; then
                elapsed="$total"
            fi
            if [ "$total" -gt 0 ]; then
                percent=$((elapsed * 100 / total))
            else
                percent=0
            fi
            if [ "$percent" -gt 100 ]; then
                percent=100
            fi
            filled=$((percent * width / 100))
            empty=$((width - filled))
            filled_bar=$(printf "%*s" "$filled" "" | tr ' ' '#')
            empty_bar=$(printf "%*s" "$empty" "" | tr ' ' '-')
            mins=$((elapsed / 60))
            secs=$((elapsed % 60))
            printf "\r%s [%s%s] %3d%% %02dm%02ds" "$label" "$filled_bar" "$empty_bar" "$percent" "$mins" "$secs"
            sleep 1
        done
    ) &
    PROGRESS_PID=$!
}

stop_progress_bar() {
    local pid="$1"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
        kill -TERM "$pid" 2>/dev/null || true
        wait "$pid" 2>/dev/null || true
    fi
    if [ -t 1 ]; then
        clear_line
    fi
}

start_spinner() {
    local label="$1"
    SPINNER_PID=""
    if [ ! -t 1 ]; then
        return 0
    fi

    (
        local spin='|/-\'
        local i=0
        while true; do
            printf "\r%s %c" "$label" "${spin:i++%4:1}"
            sleep 0.2
        done
    ) &
    SPINNER_PID=$!
}

stop_spinner() {
    local pid="$1"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
        kill -TERM "$pid" 2>/dev/null || true
        wait "$pid" 2>/dev/null || true
    fi
    if [ -t 1 ]; then
        clear_line
    fi
}

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OPERATOR_INGEST_VENV="$SCRIPT_DIR/mac_daemon/.venv-ingest"
OPERATOR_INGEST_REQ="$SCRIPT_DIR/mac_daemon/requirements.txt"
FORCE_RESTART_TRANSCRIPTION="${FORCE_RESTART_TRANSCRIPTION:-1}"

# Check if service is running on a port
check_port() {
    local port=$1
    local service_name=$2

    if lsof -nP -iTCP:"$port" -sTCP:LISTEN > /dev/null 2>&1; then
        return 0  # Port has a listener
    else
        return 1  # Port is free
    fi
}

# Check service health via HTTP
check_service_health() {
    local url=$1
    local timeout=${2:-5}
    
    if curl -s -f --max-time $timeout "$url" > /dev/null 2>&1; then
        return 0  # Service is healthy
    else
        return 1  # Service is unhealthy
    fi
}

# Read TTS status from the transcription server health endpoint
get_tts_status() {
    local health_json
    health_json=$(curl -s --max-time 3 "http://localhost:8001/v1/health" 2>/dev/null || true)
    if [ -z "$health_json" ]; then
        return 1
    fi

    echo "$health_json" | python3 - <<'PY'
import json, sys
try:
    data = json.load(sys.stdin)
except Exception:
    sys.exit(1)

enabled = bool(data.get("features", {}).get("tts_enabled"))
status = data.get("tts_status") or ("loaded" if enabled else "not_loaded")
model = data.get("tts_model") or "none"
print(f"{'enabled' if enabled else 'disabled'}|{status}|{model}")
PY
}

# Cleanup background jobs (prevents zombie processes)
cleanup_background_jobs() {
    local load_pid=$1
    local progress_pid=$2

    # Stop load process if running
    if [ -n "$load_pid" ] && kill -0 "$load_pid" 2>/dev/null; then
        kill -TERM "$load_pid" 2>/dev/null || true
        sleep 0.5
        kill -KILL "$load_pid" 2>/dev/null || true
        wait "$load_pid" 2>/dev/null || true
    fi

    # Stop progress indicator
    if [ -n "$progress_pid" ]; then
        stop_progress_bar "$progress_pid"
    fi
}

# Cleanup temporary files on exit
cleanup_on_exit() {
    # Clean up any temp files matching our pattern (older than 60 minutes)
    find /tmp -maxdepth 1 -name "whisper-startup-*.log" -user $(whoami) -mmin +60 -delete 2>/dev/null || true
    find /tmp -maxdepth 1 -name "medasr-startup-*.log" -user $(whoami) -mmin +60 -delete 2>/dev/null || true
}

# Check if lms CLI is available
check_lms_cli() {
    if ! command -v lms &> /dev/null; then
        warn "LM Studio CLI (lms) not found in PATH"
        warn "Please install LM Studio CLI: https://lmstudio.ai/docs/cli"
        warn "Or bootstrap: ~/.lmstudio/bin/lms bootstrap"
        return 1
    fi
    return 0
}

# Display available LM Studio models with optional defaults highlighted
display_model_menu() {
    local default_reasoning="$1"
    local default_quick="$2"
    shift 2
    local models=("$@")

    if [ ${#models[@]} -eq 0 ]; then
        echo "No models detected."
        return
    fi

    echo "Available models:"
    local idx=1
    for model in "${models[@]}"; do
        local annotations=""
        if [ -n "$default_reasoning" ] && [ "$model" = "$default_reasoning" ]; then
            annotations="default reasoning"
        fi
        if [ -n "$default_quick" ] && [ "$model" = "$default_quick" ]; then
            if [ -n "$annotations" ]; then
                annotations="$annotations, default quick"
            else
                annotations="default quick"
            fi
        fi

        if [ -n "$annotations" ]; then
            printf "  [%d] %s (%s)\n" "$idx" "$model" "$annotations"
        else
            printf "  [%d] %s\n" "$idx" "$model"
        fi
        ((idx++))
    done
    printf "  [0] Skip this slot\n"
    echo
}

# Prompt the user to choose a model by index, honoring defaults and skip
prompt_model_selection() {
    local role="$1"
    local default_model="$2"
    shift 2
    local models=("$@")
    local total=${#models[@]}

    if [ $total -eq 0 ]; then
        echo "$default_model"
        return 0
    fi

    local prompt_msg
    if [ -n "$default_model" ]; then
        prompt_msg="Select ${role} model [default: ${default_model}] (Enter to accept, 0 to skip): "
    else
        prompt_msg="Select ${role} model (0 to skip): "
    fi

    while true; do
        local response
        printf "%s" "$prompt_msg" >&2
        read response

        if [ -z "$response" ]; then
            echo "$default_model"
            return 0
        fi

        if [[ "$response" =~ ^[0-9]+$ ]]; then
            local idx=$response
            if [ "$idx" -eq 0 ]; then
                echo ""
                return 0
            fi
            if [ "$idx" -ge 1 ] && [ "$idx" -le "$total" ]; then
                echo "${models[$((idx-1))]}"
                return 0
            fi
        fi

        echo "Invalid selection. Please enter a number between 0 and $total." >&2
    done
}

# Normalize ASR engine selection
normalize_asr_engine() {
    local value
    value=$(echo "$1" | tr '[:upper:]' '[:lower:]')

    case "$value" in
        ""|1|whisper|mlx|mlx-whisper|mlx_whisper)
            echo "mlx-whisper"
            return 0
            ;;
        2|medasr|med-asr|google|google-medasr|google/medasr)
            echo "medasr"
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

format_asr_engine() {
    case "$1" in
        medasr)
            echo "Google MedASR"
            ;;
        mlx-whisper)
            echo "MLX Whisper"
            ;;
        *)
            echo "$1"
            ;;
    esac
}

# Prompt the user to choose ASR engine
prompt_asr_engine() {
    local default_engine="${1:-mlx-whisper}"
    local default_choice="1"
    local default_label="MLX Whisper"
    if [ "$default_engine" = "medasr" ]; then
        default_choice="2"
        default_label="Google MedASR"
    fi

    {
        echo
        echo "Transcription engine:"
        if [ "$default_engine" = "medasr" ]; then
            echo "  [1] MLX Whisper (fast)"
            echo "  [2] Google MedASR (medical accuracy testing) - default"
        else
            echo "  [1] MLX Whisper (fast) - default"
            echo "  [2] Google MedASR (medical accuracy testing)"
        fi
        echo
    } >&2

    while true; do
        local response
        printf "Choose transcription engine [%s]: " "$default_choice" >&2
        read response

        if [ -z "$response" ]; then
            echo "$default_engine"
            return 0
        fi

        local normalized
        normalized=$(normalize_asr_engine "$response") || true
        if [ -n "$normalized" ]; then
            echo "$normalized"
            return 0
        fi

        echo "Invalid selection. Please enter 1 or 2." >&2
    done
}

# Determine ASR engine selection (env override or prompt)
select_asr_engine() {
    local env_choice="${OPERATOR_ASR_ENGINE:-}"
    local default_engine="mlx-whisper"
    if [ -n "$env_choice" ]; then
        local normalized
        normalized=$(normalize_asr_engine "$env_choice") || true
        if [ -n "$normalized" ]; then
            default_engine="$normalized"
        else
            warn "Invalid OPERATOR_ASR_ENGINE value: $env_choice (defaulting to MLX Whisper)"
        fi
    fi

    if [ -t 0 ]; then
        prompt_asr_engine "$default_engine"
    else
        echo "$default_engine"
    fi
}

# Detect running transcription engine from health endpoint
detect_transcription_engine() {
    local health_json
    health_json=$(curl -s "http://localhost:8001/v1/health" 2>/dev/null || echo "")
    if [ -z "$health_json" ]; then
        return 1
    fi

    echo "$health_json" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
except Exception:
    sys.exit(1)
engine = data.get('engine')
if not engine:
    model = str(data.get('model', '')).lower()
    server = str(data.get('server', '')).lower()
    if 'whisper' in model or 'whisper' in server:
        engine = 'mlx-whisper'
    elif 'medasr' in model or 'medasr' in server:
        engine = 'medasr'
if engine:
    print(engine)
" 2>/dev/null
}

stop_transcription_port() {
    local pids
    local pid_list
    local parent_list
    local attempts=0
    local max_attempts=4

    echo "Processes listening on port 8001:"
    lsof -nP -iTCP:8001 -sTCP:LISTEN 2>/dev/null || true
    pids=$(lsof -t -nP -iTCP:8001 -sTCP:LISTEN 2>/dev/null | sort -u)

    if [ -z "$pids" ]; then
        warn "No listening process found on port 8001."
        return 1
    fi

    pid_list=$(echo "$pids" | tr '\n' ',' | sed 's/,$//')
    if [ -n "$pid_list" ]; then
        echo "Listener command lines:"
        ps -p "$pid_list" -o pid=,ppid=,stat=,user=,command= 2>/dev/null || true
        parent_list=$(ps -p "$pid_list" -o ppid= 2>/dev/null | tr -d ' ' | sort -u | tr '\n' ',' | sed 's/,$//')
        if [ -n "$parent_list" ]; then
            echo "Listener parent processes:"
            ps -p "$parent_list" -o pid=,user=,command= 2>/dev/null || true
        fi
    fi

    info "Stopping processes on port 8001..."
    for pid in $pids; do
        if kill -0 "$pid" 2>/dev/null; then
            if ! kill -TERM "$pid" 2>/dev/null; then
                warn "Failed to send SIGTERM to PID $pid."
            fi
        fi
    done

    while [ $attempts -lt $max_attempts ]; do
        sleep 1
        pids=$(lsof -t -nP -iTCP:8001 -sTCP:LISTEN 2>/dev/null | sort -u)
        if [ -z "$pids" ]; then
            return 0
        fi

        attempts=$((attempts + 1))
        warn "Port 8001 still in use; forcing stop (attempt ${attempts}/${max_attempts})..."
        for pid in $pids; do
            if kill -0 "$pid" 2>/dev/null; then
                if ! kill -KILL "$pid" 2>/dev/null; then
                    warn "Failed to send SIGKILL to PID $pid."
                fi
            fi
        done
    done

    if check_port 8001; then
        warn "Port 8001 still in use after stop attempts."
        echo "Remaining listeners on port 8001:"
        lsof -nP -iTCP:8001 -sTCP:LISTEN 2>/dev/null || true
        pids=$(lsof -t -nP -iTCP:8001 -sTCP:LISTEN 2>/dev/null | sort -u)
        pid_list=$(echo "$pids" | tr '\n' ',' | sed 's/,$//')
        if [ -n "$pid_list" ]; then
            echo "Remaining listener command lines:"
            ps -p "$pid_list" -o pid=,ppid=,stat=,user=,command= 2>/dev/null || true
            if ps -p "$pid_list" -o stat= 2>/dev/null | grep -q "U"; then
                warn "One or more listeners appear stuck in uninterruptible sleep."
                warn "macOS will not kill these until the kernel unblocks; a reboot may be required."
            fi
            parent_list=$(ps -p "$pid_list" -o ppid= 2>/dev/null | tr -d ' ' | sort -u | tr '\n' ',' | sed 's/,$//')
            if [ -n "$parent_list" ]; then
                echo "Remaining listener parent processes:"
                ps -p "$parent_list" -o pid=,user=,command= 2>/dev/null || true
                if ps -p "$parent_list" -o command= 2>/dev/null | grep -q "launchd"; then
                    local launchd_label=""
                    local launchd_label_found=0
                    for pid in $pids; do
                        launchd_label=$(launchctl list 2>/dev/null | awk -v target="$pid" '$1 == target {print $3}')
                        if [ -n "$launchd_label" ]; then
                            launchd_label_found=1
                            warn "Launchd job for PID ${pid}: ${launchd_label}"
                        fi
                    done
                    if [ "$launchd_label_found" -eq 1 ]; then
                        warn "Transcription server appears to be supervised by launchd."
                        warn "Check LaunchAgents: launchctl list | grep -i whisper"
                        warn "Stop job: launchctl stop <label> (or bootout gui/$(id -u)/<label>)"
                    else
                        warn "Parent is launchd (PID 1), but no launchd label was found for the listener."
                        warn "That usually means the process is orphaned, so launchctl list won't show it."
                    fi
                fi
            fi
        fi
        warn "If these are not owned by your user, you may need elevated permissions to stop them."
        return 1
    fi

    return 0
}

# Start LMStudio server and load both models
ensure_lmstudio_server() {
    info "LM Studio: checking server (localhost:1234)..."
    
    # Check if CLI is available
    if ! check_lms_cli; then
        warn "LM Studio CLI missing; please start LM Studio manually."
        warn "Load models:"
        warn "  1. Reasoning: lmstudio-community/medgemma-27b-text-it-MLX-4bit"
        warn "  2. Quick: qwen/qwen3-4b-2507"
        return 1
    fi
    
    # Check if server is running
    if ! check_service_health "http://localhost:1234/v1/models" 3; then
        info "LM Studio: starting server..."
        if ! lms server start > /dev/null 2>&1; then
            error "Failed to start LM Studio server via CLI"
            return 1
        fi
        
        # Wait for server to start
        local retries=0
        while [ $retries -lt 30 ]; do
            if check_service_health "http://localhost:1234/v1/models" 3; then
                success "LM Studio server started"
                break
            fi
            sleep 1
            ((retries++))
        done
        
        if [ $retries -eq 30 ]; then
            error "LM Studio server failed to start within 30 seconds"
            return 1
        fi
    else
        success "LM Studio server already running"
    fi
    
    # Ensure both models are loaded
    ensure_dual_models_loaded
    return $?
}

# Load both medical models (reasoning + quick)
ensure_dual_models_loaded() {
    info "LM Studio: verifying models..."

    # First, discover what models are actually downloaded
    info "LM Studio: discovering available models..."
    local available_models=$(lms ls 2>/dev/null || echo "")

    if [ -z "$available_models" ]; then
        warn "Unable to list models. Make sure LM Studio CLI is properly configured."
        return 1
    fi

    # Prepare list of model ids for interactive selection
    local models_for_prompt=()
    while IFS= read -r model_id; do
        case "$model_id" in
            ""|"MODEL"|"Model"|"NAME"|"Name"|"ID"|"Id")
                continue
                ;;
        esac

        local exists=0
        for existing in "${models_for_prompt[@]}"; do
            if [ "$existing" = "$model_id" ]; then
                exists=1
                break
            fi
        done
        if [ $exists -eq 0 ]; then
            models_for_prompt+=("$model_id")
        fi
    done < <(echo "$available_models" | awk '{print $1}' | sed 's/\r$//')

    # Find reasoning model (medgemma variants)
    local reasoning_model=$(echo "$available_models" | grep -i "medgemma" | head -1 | awk '{print $1}')
    # Find quick model: prioritize qwen3-4b, then fall back to gemma variants
    local quick_model=$(echo "$available_models" | grep -iE "qwen.*3.*4b" | head -1 | awk '{print $1}')
    if [ -z "$quick_model" ]; then
        # Fallback: try gemma-3n variants
        quick_model=$(echo "$available_models" | grep -iE "gemma.*(3n|3-n|-3n|3_n)" | grep -v "medgemma" | head -1 | awk '{print $1}')
    fi

    if [ -z "$reasoning_model" ] && [ -z "$quick_model" ]; then
        # Final fallback: any gemma model
        quick_model=$(echo "$available_models" | grep -i "gemma" | grep -v "medgemma" | head -1 | awk '{print $1}')
    fi

    local reasoning_user_skipped=0
    local quick_user_skipped=0

    if [ -t 0 ] && [ ${#models_for_prompt[@]} -gt 0 ]; then
        section "LM Studio Models"
        display_model_menu "$reasoning_model" "$quick_model" "${models_for_prompt[@]}"

        local selected_reasoning
        selected_reasoning=$(prompt_model_selection "reasoning" "$reasoning_model" "${models_for_prompt[@]}")
        if [ -z "$selected_reasoning" ]; then
            reasoning_model=""
            reasoning_user_skipped=1
        else
            reasoning_model="$selected_reasoning"
        fi

        local selected_quick
        selected_quick=$(prompt_model_selection "quick" "$quick_model" "${models_for_prompt[@]}")
        if [ -z "$selected_quick" ]; then
            quick_model=""
            quick_user_skipped=1
        else
            quick_model="$selected_quick"
        fi
        echo
    fi

    info "Selected models:"
    if [ -n "$reasoning_model" ]; then
        log "Reasoning: $reasoning_model"
    else
        if [ $reasoning_user_skipped -eq 1 ]; then
            warn "Reasoning: skipped"
        else
            warn "Reasoning: no MedGemma model detected"
        fi
    fi
    if [ -n "$quick_model" ]; then
        log "Quick: $quick_model"
    else
        if [ $quick_user_skipped -eq 1 ]; then
            warn "Quick: skipped"
        else
            warn "Quick: no quick model detected"
        fi
    fi

    local reasoning_loaded=0
    local quick_loaded=0

    # Check what models are currently loaded
    local loaded_models=$(lms ps 2>/dev/null || echo "")
    if echo "$loaded_models" | grep -q "medgemma" 2>/dev/null; then
        reasoning_loaded=1
        success "Reasoning model already loaded"
    fi

    if echo "$loaded_models" | grep -qiE "(qwen.*3.*4b|gemma.*(3n|3-n|-3n|3_n))" 2>/dev/null; then
        quick_loaded=1
        success "Quick model already loaded"
    fi

    # Load models in parallel if both needed (saves ~2-3 minutes)
    local need_reasoning=$([[ $reasoning_loaded -eq 0 && ! -z "$reasoning_model" ]] && echo 1 || echo 0)
    local need_quick=$([[ $quick_loaded -eq 0 && ! -z "$quick_model" ]] && echo 1 || echo 0)

    if [ $need_reasoning -eq 1 ] && [ $need_quick -eq 1 ]; then
        info "Loading models in parallel (faster startup)..."
        log "Reasoning: $reasoning_model"
        log "Quick: $quick_model"

        local parallel_start=$(date +%s)

        # Start both loads in background
        (run_with_timeout 600 lms load "$reasoning_model" 2>&1) > /dev/null 2>&1 &
        local reasoning_pid=$!

        (run_with_timeout 300 lms load "$quick_model" 2>&1) > /dev/null 2>&1 &
        local quick_pid=$!

        # Single progress indicator for both
        local progress_pid
        start_progress_bar "Loading models" 600
        progress_pid=$PROGRESS_PID

        # Poll for both models with unified timeout (10 min max)
        local poll_count=0
        while [ $poll_count -lt 200 ]; do
            sleep 3
            ((poll_count++))

            local loaded_models=$(lms ps 2>/dev/null || echo "")

            # Check reasoning model
            if [ $reasoning_loaded -eq 0 ] && echo "$loaded_models" | grep -q "medgemma" 2>/dev/null; then
                reasoning_loaded=1
            fi

            # Check quick model
            if [ $quick_loaded -eq 0 ] && echo "$loaded_models" | grep -qiE "(qwen.*3.*4b|gemma.*(3n|3-n|-3n|3_n))" 2>/dev/null; then
                quick_loaded=1
            fi

            # Exit when both loaded or both processes finished
            if [ $reasoning_loaded -eq 1 ] && [ $quick_loaded -eq 1 ]; then
                break
            fi

            # Check if processes finished
            local reasoning_done=$(! kill -0 $reasoning_pid 2>/dev/null && echo 1 || echo 0)
            local quick_done=$(! kill -0 $quick_pid 2>/dev/null && echo 1 || echo 0)

            if [ $reasoning_done -eq 1 ] && [ $quick_done -eq 1 ]; then
                # Final check
                local final_models=$(lms ps 2>/dev/null || echo "")
                echo "$final_models" | grep -q "medgemma" 2>/dev/null && reasoning_loaded=1
                echo "$final_models" | grep -qiE "(qwen.*3.*4b|gemma.*(3n|3-n|-3n|3_n))" 2>/dev/null && quick_loaded=1
                break
            fi
        done

        # Cleanup
        cleanup_background_jobs "$reasoning_pid" "$progress_pid"
        [ -n "$quick_pid" ] && kill -TERM "$quick_pid" 2>/dev/null || true
        wait "$quick_pid" 2>/dev/null || true

        local parallel_time=$(($(date +%s) - parallel_start))
        if [ $reasoning_loaded -eq 1 ] && [ $quick_loaded -eq 1 ]; then
            success "Models ready (reasoning + quick, ${parallel_time}s)"
        elif [ $reasoning_loaded -eq 1 ] || [ $quick_loaded -eq 1 ]; then
            warn "Partial load after ${parallel_time}s - retrying missing model..."
        else
            warn "Parallel load timed out after ${parallel_time}s - retrying sequentially..."
        fi

    fi

    # Load reasoning model individually if still needed
    if [ $reasoning_loaded -eq 0 ] && [ ! -z "$reasoning_model" ]; then
        info "Loading reasoning model..."
        log "$reasoning_model"
        log "Timeout: 10 minutes"

        local start_time=$(date +%s)
        local progress_pid
        start_progress_bar "Loading reasoning" 600
        progress_pid=$PROGRESS_PID

        (run_with_timeout 600 lms load "$reasoning_model" 2>&1) > /dev/null 2>&1 &
        local load_pid=$!

        local poll_count=0
        while [ $poll_count -lt 200 ]; do
            sleep 3
            ((poll_count++))

            if lms ps 2>/dev/null | grep -q "medgemma" 2>/dev/null; then
                reasoning_loaded=1
                break
            fi

            if ! kill -0 $load_pid 2>/dev/null; then
                lms ps 2>/dev/null | grep -q "medgemma" 2>/dev/null && reasoning_loaded=1
                break
            fi
        done

        cleanup_background_jobs "$load_pid" "$progress_pid"

        if [ $reasoning_loaded -eq 1 ]; then
            success "Reasoning model ready ($(($(date +%s) - start_time))s)"
        else
            # Try short name fallback
            local short_name=$(echo "$reasoning_model" | cut -d'/' -f2)
            if [ ! -z "$short_name" ] && [ "$short_name" != "$reasoning_model" ]; then
                info "Trying short name: $short_name"
                run_with_timeout 300 lms load "$short_name" 2>&1 && reasoning_loaded=1
            fi
        fi
    fi

    # Load quick model individually if still needed
    if [ $quick_loaded -eq 0 ] && [ ! -z "$quick_model" ]; then
        info "Loading quick model..."
        log "$quick_model"
        log "Timeout: 5 minutes"

        local start_time=$(date +%s)
        local progress_pid
        start_progress_bar "Loading quick" 300
        progress_pid=$PROGRESS_PID

        (run_with_timeout 300 lms load "$quick_model" 2>&1) > /dev/null 2>&1 &
        local load_pid=$!

        local poll_count=0
        while [ $poll_count -lt 150 ]; do
            sleep 2
            ((poll_count++))

            if lms ps 2>/dev/null | grep -qiE "(qwen.*3.*4b|gemma.*(3n|3-n|-3n|3_n))" 2>/dev/null; then
                quick_loaded=1
                break
            fi

            if ! kill -0 $load_pid 2>/dev/null; then
                lms ps 2>/dev/null | grep -qiE "(qwen.*3.*4b|gemma.*(3n|3-n|-3n|3_n))" 2>/dev/null && quick_loaded=1
                break
            fi
        done

        cleanup_background_jobs "$load_pid" "$progress_pid"

        if [ $quick_loaded -eq 1 ]; then
            success "Quick model ready ($(($(date +%s) - start_time))s)"
        else
            # Try short name fallback
            local short_name=$(echo "$quick_model" | cut -d'/' -f2)
            if [ ! -z "$short_name" ] && [ "$short_name" != "$quick_model" ]; then
                info "Trying short name: $short_name"
                run_with_timeout 180 lms load "$short_name" 2>&1 && quick_loaded=1
            fi
        fi
    fi
    
    # Verify both models are loaded
    if [ $reasoning_loaded -eq 1 ] && [ $quick_loaded -eq 1 ]; then
        success "All models ready"
        return 0
    elif [ $reasoning_loaded -eq 1 ] || [ $quick_loaded -eq 1 ]; then
        warn "Some models are missing; functionality may be limited"
        if [ $reasoning_loaded -eq 0 ]; then
            if [ $reasoning_user_skipped -eq 1 ]; then
                info "Reasoning model skipped by user"
            else
                warn "Missing reasoning model"
            fi
        fi
        if [ $quick_loaded -eq 0 ]; then
            if [ $quick_user_skipped -eq 1 ]; then
                info "Quick model skipped by user"
            else
                warn "Missing quick model"
            fi
        fi
        warn "Extension will run with reduced capabilities"
        return 1
    else
        if [ $reasoning_user_skipped -eq 1 ] && [ $quick_user_skipped -eq 1 ]; then
            warn "No models loaded (both selections skipped)"
            warn "Load models in LM Studio and rerun ./dev"
            return 1
        fi
        error "No models loaded"
        error "Check:"
        error "  1. Models are downloaded in LM Studio"
        error "  2. LM Studio server is running"
        error "  3. System memory is available"
        error "  4. Try: lms load <model-name>"
        return 1
    fi
}

# Start Google MedASR server if needed
ensure_medasr_server() {
    info "MedASR: checking server (localhost:8001)..."

    if check_service_health "http://localhost:8001/v1/health"; then
        success "MedASR server already running"
        return 0
    fi

    if [ -f "./start-medasr-server.sh" ]; then
        info "MedASR: starting server..."

        local medasr_log="/tmp/medasr-startup-$$.log"

        ./start-medasr-server.sh >"$medasr_log" 2>&1 &
        local medasr_pid=$!
        local progress_pid
        start_progress_bar "Starting MedASR" 90
        progress_pid=$PROGRESS_PID

        local retries=0
        while [ $retries -lt 90 ]; do
            if check_service_health "http://localhost:8001/v1/health"; then
                stop_progress_bar "$progress_pid"
                success "MedASR server ready"
                rm -f "$medasr_log"
                return 0
            fi

            if ! kill -0 $medasr_pid 2>/dev/null; then
                stop_progress_bar "$progress_pid"
                error "MedASR server failed to start (process exited)"
                if [ -f "$medasr_log" ]; then
                    error "Startup log (last 30 lines):"
                    tail -30 "$medasr_log" | while IFS= read -r line; do
                        log "$line"
                    done
                    error "Common fixes:"
                    error "  1. source venv-medasr/bin/activate && pip install -r requirements-medasr.txt"
                    error "  2. python3 --version (requires 3.8+)"
                    error "  3. rm -rf venv-medasr && ./start-medasr-server.sh"
                    rm -f "$medasr_log"
                fi
                return 1
            fi

            sleep 1
            ((retries++))
        done

        stop_progress_bar "$progress_pid"
        error "MedASR server failed to start (timeout after 90s)"
        if [ -f "$medasr_log" ]; then
            warn "Startup log (last 30 lines):"
            tail -30 "$medasr_log" | while IFS= read -r line; do
                log "$line"
            done
            rm -f "$medasr_log"
        fi
        return 1
    else
        warn "MedASR startup script not found: ./start-medasr-server.sh"
        warn "Please start MedASR manually"
        return 1
    fi
}

# Start transcription server based on selected engine
ensure_transcription_server() {
    local engine="${1:-mlx-whisper}"
    local desired_engine
    desired_engine=$(normalize_asr_engine "$engine") || desired_engine="mlx-whisper"

    info "Transcription: checking server (localhost:8001)..."
    if check_port 8001; then
        if [ "$FORCE_RESTART_TRANSCRIPTION" = "1" ]; then
            local running_engine=""
            if check_service_health "http://localhost:8001/v1/health"; then
                running_engine=$(detect_transcription_engine || echo "")
            fi
            if [ -n "$running_engine" ]; then
                warn "Transcription already running (${running_engine}); restarting for a clean boot."
            else
                warn "Port 8001 in use; restarting transcription server for a clean boot."
            fi
            if ! stop_transcription_port; then
                return 1
            fi
        else
            if check_service_health "http://localhost:8001/v1/health"; then
                local running_engine
                running_engine=$(detect_transcription_engine || echo "")
                if [ -z "$running_engine" ]; then
                    running_engine="unknown"
                fi

                if [ "$running_engine" = "$desired_engine" ]; then
                    log "Transcription server is already running (${running_engine})"
                    return 0
                fi

                warn "Transcription already running (${running_engine})."
                warn "Stop it to start ${desired_engine} on port 8001."

                if [ -t 0 ]; then
                    local response
                    echo "Processes on port 8001:"
                    lsof -i :8001 2>/dev/null || true
                    read -p "Stop existing transcription server to switch to ${desired_engine}? [y/N]: " response
                    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
                    if [[ "$response" == "y" || "$response" == "yes" ]]; then
                        if ! stop_transcription_port; then
                            return 1
                        fi
                    else
                        return 1
                    fi
                else
                    warn "Use: lsof -i :8001 && kill <pid>"
                    return 1
                fi
            else
                warn "Port 8001 in use but /v1/health is not responding."
                warn "Stop the process on port 8001 and retry."
                return 1
            fi
        fi
    fi

    if check_port 8001; then
        warn "Port 8001 still in use after stop attempt."
        return 1
    fi

    if [ "$desired_engine" = "medasr" ]; then
        ensure_medasr_server
    else
        ensure_whisper_server
    fi
}

# Start MLX Whisper server if needed
ensure_whisper_server() {
    info "MLX Whisper: checking server (localhost:8001)..."

    if check_service_health "http://localhost:8001/v1/health"; then
        success "MLX Whisper server already running"
        return 0
    fi

    if [ -f "./start-whisper-server.sh" ]; then
        info "MLX Whisper: starting server..."

        # Create a temporary log file for startup errors
        local whisper_log="/tmp/whisper-startup-$$.log"

        # Start the server and capture output
        ./start-whisper-server.sh >"$whisper_log" 2>&1 &
        local whisper_pid=$!
        local progress_pid
        start_progress_bar "Starting MLX Whisper" 60
        progress_pid=$PROGRESS_PID

        # Wait for server to start (longer timeout to allow for dependency installation)
        local retries=0
        while [ $retries -lt 60 ]; do
            if check_service_health "http://localhost:8001/v1/health"; then
                stop_progress_bar "$progress_pid"
                success "MLX Whisper server ready"
                rm -f "$whisper_log"
                return 0
            fi

            # Check if the process is still running
            if ! kill -0 $whisper_pid 2>/dev/null; then
                stop_progress_bar "$progress_pid"
                error "MLX Whisper server failed to start (process exited)"
                if [ -f "$whisper_log" ]; then
                    error "Startup log (last 30 lines):"
                    tail -30 "$whisper_log" | while IFS= read -r line; do
                        log "$line"
                    done
                    error "Common fixes:"
                    error "  1. source venv-whisper/bin/activate && pip install -r requirements-whisper.txt"
                    error "  2. python3 --version (requires 3.8+)"
                    error "  3. rm -rf venv-whisper && ./start-whisper-server.sh"
                    rm -f "$whisper_log"
                fi
                return 1
            fi

            sleep 1
            ((retries++))
        done

        stop_progress_bar "$progress_pid"
        error "MLX Whisper server failed to start (timeout after 60s)"
        if [ -f "$whisper_log" ]; then
            warn "Startup log (last 30 lines):"
            tail -30 "$whisper_log" | while IFS= read -r line; do
                log "$line"
            done
            rm -f "$whisper_log"
        fi
        return 1
    else
        warn "MLX Whisper startup script not found: ./start-whisper-server.sh"
        warn "Please start MLX Whisper manually"
        return 1
    fi
}

# Start DSPy server if needed  
ensure_dspy_server() {
    info "DSPy: checking server (localhost:8002)..."
    
    if check_service_health "http://localhost:8002/v1/health"; then
        success "DSPy server already running"
        return 0
    fi
    
    if [ -f "./start-dspy-server.sh" ]; then
        info "DSPy: starting server..."
        ./start-dspy-server.sh start > /dev/null 2>&1
        
        # Wait for server to start
        local retries=0
        while [ $retries -lt 20 ]; do
            if check_service_health "http://localhost:8002/v1/health"; then
                success "DSPy server ready"
                return 0
            fi
            sleep 1
            ((retries++))
        done
        
        error "DSPy server failed to start"
        return 1
    else
        error "DSPy startup script not found: ./start-dspy-server.sh"
        return 1
    fi
}

# Prepare Python environment for Operator Ingest
ensure_operator_ingest_env() {
    if [ ! -f "$OPERATOR_INGEST_REQ" ]; then
        warn "Operator Ingest requirements not found; skipping autostart"
        return 1
    fi

    if ! command -v python3 >/dev/null 2>&1; then
        warn "Cannot prepare Operator Ingest environment: python3 missing"
        return 1
    fi

    if [ ! -d "$OPERATOR_INGEST_VENV" ]; then
        info "Creating Operator Ingest virtual environment..."
        if ! python3 -m venv "$OPERATOR_INGEST_VENV" >/dev/null 2>&1; then
            warn "Failed to create Operator Ingest virtual environment"
            return 1
        fi
    fi

    local venv_pip="$OPERATOR_INGEST_VENV/bin/pip"
    local venv_python="$OPERATOR_INGEST_VENV/bin/python"
    if [ ! -x "$venv_pip" ] || [ ! -x "$venv_python" ]; then
        warn "Operator Ingest virtual environment missing pip/python"
        return 1
    fi

    local hash_file="$OPERATOR_INGEST_VENV/.requirements-hash"
    local req_hash current_hash
    req_hash=$(shasum "$OPERATOR_INGEST_REQ" | awk '{print $1}')
    [ -f "$hash_file" ] && current_hash=$(cat "$hash_file") || current_hash=""

    if [ "$req_hash" != "$current_hash" ]; then
        info "Installing/updating Operator Ingest dependencies..."
        if ! "$venv_pip" install -r "$OPERATOR_INGEST_REQ" >/dev/null 2>&1; then
            warn "Failed to install Operator Ingest dependencies"
            return 1
        fi
        echo "$req_hash" > "$hash_file"
    fi

    return 0
}

# Start Operator Ingest menubar app if not already running
start_operator_ingest_app() {
    info "Operator Ingest: checking menubar app..."

    if pgrep -f "mac_daemon.main" >/dev/null 2>&1; then
        success "Operator Ingest already running"
        return 0
    fi

    if ! ensure_operator_ingest_env; then
        warn "Skipping Operator Ingest autostart (environment not ready)"
        return 1
    fi

    local log_file="/tmp/operator-ingest-$(date +%s).log"
    local venv_python="$OPERATOR_INGEST_VENV/bin/python"

    if [ ! -x "$venv_python" ]; then
        warn "Operator Ingest python missing; skipping autostart"
        return 1
    fi

    info "Operator Ingest: starting (logs: $log_file)"

    local app_pid
    # Note: mac_daemon is a menubar app, so we let it show its menubar icon
    # It won't show a dock icon because it's designed as a status bar app
    app_pid=$(
        cd "$SCRIPT_DIR" || exit 1
        nohup "$venv_python" -m mac_daemon.main >>"$log_file" 2>&1 &
        echo $!
    )

    if [ -n "$app_pid" ]; then
        echo "$app_pid" > /tmp/operator-ingest.pid
        success "Operator Ingest started (pid $app_pid)"
    else
        warn "Failed to start Operator Ingest (see $log_file)"
    fi
}

start_wardround_watcher() {
    info "Ward round watcher: checking..."

    if pgrep -f "wardround:watch" >/dev/null 2>&1; then
        success "Ward round watcher already running"
        return 0
    fi

    if ! command -v npm >/dev/null 2>&1; then
        warn "Skipping ward round watcher start (npm missing)"
        return 1
    fi

    local log_file="/tmp/wardround-watcher-$(date +%s).log"
    info "Ward round watcher: starting (logs: $log_file)"

    local watcher_pid
    watcher_pid=$(
        cd "$SCRIPT_DIR" || exit 1
        nohup npm run wardround:watch >>"$log_file" 2>&1 &
        echo $!
    )

    if [ -n "$watcher_pid" ]; then
        echo "$watcher_pid" > /tmp/wardround-watcher.pid
        success "Ward round watcher started (pid $watcher_pid)"
    else
        warn "Failed to start ward round watcher (see $log_file)"
    fi
}

# Display comprehensive service status with model information
show_service_status() {
    section "Service Status"
    
    # LMStudio (Model Serving) with dual model status
    if check_service_health "http://localhost:1234/v1/models" 3; then
        success "LM Studio: http://localhost:1234"
        
        # Show loaded models with details
        if command -v lms &> /dev/null; then
            local models_info=$(lms ps 2>/dev/null || echo "")
            if [ ! -z "$models_info" ]; then
                # Detect reasoning model (medgemma)
                local reasoning_model=$(echo "$models_info" | grep -i "medgemma" | head -1 | awk '{print $1}')
                if [ ! -z "$reasoning_model" ]; then
                    log "Reasoning model: $reasoning_model"
                else
                    warn "Reasoning model: not loaded"
                fi

                # Detect quick model (qwen or gemma variants)
                local quick_model=$(echo "$models_info" | grep -iE "qwen.*3.*4b" | head -1 | awk '{print $1}')
                if [ -z "$quick_model" ]; then
                    quick_model=$(echo "$models_info" | grep -iE "gemma.*(3n|3-n|-3n|3_n)" | grep -v "medgemma" | head -1 | awk '{print $1}')
                fi
                if [ ! -z "$quick_model" ]; then
                    log "Quick model: $quick_model"
                else
                    warn "Quick model: not loaded"
                fi
            fi
        fi
    else
        warn "LM Studio: http://localhost:1234 (not reachable)"
    fi
    
    # Transcription (ASR)
    if check_service_health "http://localhost:8001/v1/health"; then
        local asr_engine
        asr_engine=$(detect_transcription_engine || echo "unknown")
        success "Transcription: http://localhost:8001 ($(format_asr_engine "$asr_engine"))"
        local tts_info
        tts_info=$(get_tts_status 2>/dev/null || echo "")
        if [ -n "$tts_info" ]; then
            local tts_state tts_status tts_model
            IFS='|' read -r tts_state tts_status tts_model <<< "$tts_info"
            if [ "$tts_state" = "enabled" ]; then
                log "TTS: enabled (${tts_model})"
            else
                warn "TTS: disabled (${tts_status})"
                log "Enable: pip install mlx-audio librosa mlx-lm einops"
            fi
        fi
    else
        warn "Transcription: http://localhost:8001 (not reachable)"
    fi
    
    # DSPy Server (Optimization + SDK Streaming)
    if check_service_health "http://localhost:8002/v1/health"; then
        success "DSPy: http://localhost:8002"

        # Get DSPy server details including SDK status
        local dspy_status=$(curl -s "http://localhost:8002/v1/health" 2>/dev/null || echo "")
        if [ ! -z "$dspy_status" ]; then
            local stats_info=$(echo "$dspy_status" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    agents = data.get('dspy', {}).get('enabled_agents', [])
    requests = data.get('stats', {}).get('requests_processed', 0)
    sdk_info = data.get('lmstudio_sdk', {})
    sdk_enabled = sdk_info.get('enabled', False)
    sdk_connected = sdk_info.get('connected', False)

    print(f'Enabled agents: {len(agents)}')
    print(f'Requests processed: {requests}')
    if sdk_enabled and sdk_connected:
        print(f'LM Studio SDK: connected (streaming enabled)')
    elif sdk_enabled:
        print(f'LM Studio SDK: enabled, not connected')
    else:
        print(f'LM Studio SDK: disabled')
except:
    pass
" 2>/dev/null || echo "Status details unavailable")
            while IFS= read -r line; do
                log "$line"
            done <<< "$stats_info"
        fi
    else
        warn "DSPy: http://localhost:8002 (not reachable)"
    fi
    
    section "Quick Commands"
    log "./dev                                    # Restart all servers"
    log "curl http://localhost:1234/v1/models     # Check LM Studio"
    log "curl http://localhost:8001/v1/health     # Check transcription"
    log "curl http://localhost:8002/v1/health     # Check DSPy"

    section "Development Workflow"
    log "npm run eval:angiogram                   # Evaluate with DSPy"
    log "npm run optim:angiogram                  # GEPA optimization"
    log "USE_DSPY=true npm run eval:quick-letter  # Enable DSPy mode"
}

# Main execution
main() {
    # Set up cleanup trap for temp files
    trap cleanup_on_exit EXIT

    section "Operator Dev Environment"
    info "Starting services..."

    local lmstudio_ok=0
    local whisper_ok=0
    local dspy_ok=0
    local asr_engine="mlx-whisper"

    local interactive_shell=0
    if [ -t 0 ] && [ -t 1 ]; then
        interactive_shell=1
    fi

    # IMPORTANT: Complete LMStudio setup FIRST in interactive mode to avoid output conflicts
    if [ $interactive_shell -eq 1 ]; then
        # LMStudio with model selection (interactive - must complete first)
        if ensure_lmstudio_server; then
            echo "1" > /tmp/lmstudio-ok.$$
            lmstudio_ok=1
        else
            echo "0" > /tmp/lmstudio-ok.$$
            lmstudio_ok=0
        fi

        asr_engine=$(select_asr_engine)
        info "Transcription engine: $(format_asr_engine "$asr_engine")"

        # Now start transcription and DSPy in parallel (no user input needed)
        info "Starting transcription + DSPy..."

        (ensure_transcription_server "$asr_engine" && echo "1" > /tmp/whisper-ok.$$ || echo "0" > /tmp/whisper-ok.$$) &
        local whisper_pid=$!

        (ensure_dspy_server && echo "1" > /tmp/dspy-ok.$$ || echo "0" > /tmp/dspy-ok.$$) &
        local dspy_pid=$!

        # Wait for both services
        wait $whisper_pid 2>/dev/null
        wait $dspy_pid 2>/dev/null
    else
        # Non-interactive: start all services in parallel (saves 13-70 seconds)
        info "Starting services in parallel..."

        (ensure_lmstudio_server && echo "1" > /tmp/lmstudio-ok.$$ || echo "0" > /tmp/lmstudio-ok.$$) &
        local lms_pid=$!

        asr_engine=$(select_asr_engine)
        (ensure_transcription_server "$asr_engine" && echo "1" > /tmp/whisper-ok.$$ || echo "0" > /tmp/whisper-ok.$$) &
        local whisper_pid=$!

        (ensure_dspy_server && echo "1" > /tmp/dspy-ok.$$ || echo "0" > /tmp/dspy-ok.$$) &
        local dspy_pid=$!

        # Wait for all services to complete
        wait $lms_pid 2>/dev/null
        wait $whisper_pid 2>/dev/null
        wait $dspy_pid 2>/dev/null
    fi

    # Read status from temp files
    [ -f /tmp/lmstudio-ok.$$ ] && lmstudio_ok=$(cat /tmp/lmstudio-ok.$$) || lmstudio_ok=0
    [ -f /tmp/whisper-ok.$$ ] && whisper_ok=$(cat /tmp/whisper-ok.$$) || whisper_ok=0
    [ -f /tmp/dspy-ok.$$ ] && dspy_ok=$(cat /tmp/dspy-ok.$$) || dspy_ok=0

    # Cleanup temp files
    rm -f /tmp/lmstudio-ok.$$ /tmp/whisper-ok.$$ /tmp/dspy-ok.$$
    
    # Show comprehensive status
    show_service_status
    
    # Summary
    local total_services=3
    local running_services=$((lmstudio_ok + whisper_ok + dspy_ok))
    
    if [ $running_services -eq $total_services ]; then
        success "Environment ready (all services running)"
        log "Operator extension: full Medical AI + DSPy streaming enabled"
    elif [ $running_services -gt 0 ]; then
        warn "$running_services/$total_services services running (limited functionality)"
        warn "Check status above and restart failed services"
    else
        error "No services are running"
        error "Check logs and ensure LM Studio CLI + models are available"
        exit 1
    fi

    start_operator_ingest_app
    start_wardround_watcher
}

# Handle command line arguments
case "${1:-}" in
    --help|-h)
        echo "Medical AI Development Environment Startup"
        echo ""
        echo "Usage: ./dev [OPTIONS]"
        echo ""
        echo "OPTIONS:"
        echo "  --help, -h     Show this help message"
        echo "  --status, -s   Show service status only"
        echo ""
        echo "This script starts all required services:"
        echo "  - LMStudio (localhost:1234) with dual models"
        echo "  - Transcription (localhost:8001) for MLX Whisper or Google MedASR"
        echo "  - DSPy Server (localhost:8002) for optimization"
        exit 0
        ;;
    --status|-s)
        show_service_status
        exit 0
        ;;
esac

# Trap signals for clean output
trap 'echo; error "Interrupted"; exit 1' INT TERM

# Run main function
main "$@"
