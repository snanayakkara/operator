# Enhanced ASR Correction Engine
# Consolidates static and dynamic ASR correction systems
# Files affected: ASRCorrections.ts, DynamicASRCorrections.ts, BloodsAgent.ts

--- /dev/null
+++ b/src/utils/asr/ASRCorrectionEngine.ts
@@ -0,0 +1,200 @@
+/**
+ * Enhanced ASR Correction Engine
+ * Consolidates static and dynamic ASR correction systems
+ * 
+ * Replaces:
+ * - ASRCorrections.applyASRCorrections()
+ * - DynamicASRCorrections.applyEnhancedCorrections()  
+ * - BloodsAgent.applyBloodsASRCorrections()
+ * - Agent-specific ASR correction logic
+ */
+
+import { logger } from '@/utils/Logger';
+import { OptimizationService } from '@/services/OptimizationService';
+import { ASRCorrections, getCombinedPatterns, type ReplacementPattern, type ASRCorrectionCategories } from './ASRCorrections';
+import type { ASRCurrentState } from '@/types/optimization';
+
+export interface ASRCorrectionConfig {
+  categories: (keyof ASRCorrectionCategories)[] | 'all';
+  enableDynamic?: boolean;
+  customRules?: CorrectionRule[];
+  validationEnabled?: boolean;
+  australianTerms?: boolean;
+  medicalDomain?: string;
+}
+
+export interface CorrectionRule {
+  raw: string;
+  fix: string;
+  category: string;
+  confidence: number;
+  medicalDomain?: string;
+}
+
+export interface ValidationResult {
+  isValid: boolean;
+  reason: string;
+  suggestions?: string[];
+}
+
+export interface CorrectionStats {
+  staticPatterns: number;
+  dynamicRules: number;
+  customRules: number;
+  lastUpdated: Date | null;
+  cacheValid: boolean;
+}
+
+export class ASRCorrectionEngine {
+  private static instance: ASRCorrectionEngine;
+  private optimizationService: OptimizationService;
+  private customRules: Map<string, CorrectionRule[]> = new Map();
+  
+  // Cache for dynamic corrections
+  private dynamicCorrections: {
+    glossaryTerms: string[];
+    correctionRules: Array<{ raw: string; fix: string }>;
+    lastUpdated: number;
+  } | null = null;
+  
+  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
+
+  private constructor() {
+    this.optimizationService = OptimizationService.getInstance();
+    logger.info('ASRCorrectionEngine initialized');
+  }
+
+  public static getInstance(): ASRCorrectionEngine {
+    if (!ASRCorrectionEngine.instance) {
+      ASRCorrectionEngine.instance = new ASRCorrectionEngine();
+    }
+    return ASRCorrectionEngine.instance;
+  }
+
+  /**
+   * Primary correction interface
+   * Consolidates all ASR correction logic with configurable behavior
+   */
+  async applyCorrections(text: string, config: ASRCorrectionConfig = { categories: 'all' }): Promise<string> {
+    try {
+      let correctedText = text;
+
+      // Apply static corrections first
+      correctedText = this.applyStaticCorrections(correctedText, config.categories);
+
+      // Apply dynamic corrections if enabled
+      if (config.enableDynamic) {
+        const dynamicCorrections = await this.getDynamicCorrections();
+        if (dynamicCorrections && dynamicCorrections.correctionRules.length > 0) {
+          correctedText = this.applyDynamicRules(correctedText, dynamicCorrections.correctionRules);
+        }
+      }
+
+      // Apply custom rules if provided
+      if (config.customRules && config.customRules.length > 0) {
+        correctedText = this.applyCustomRules(correctedText, config.customRules);
+      }
+
+      // Apply domain-specific rules
+      if (config.medicalDomain) {
+        const domainRules = this.customRules.get(config.medicalDomain);
+        if (domainRules) {
+          correctedText = this.applyCustomRules(correctedText, domainRules);
+        }
+      }
+
+      // Apply Australian medical terms if requested
+      if (config.australianTerms) {
+        correctedText = this.applyAustralianSpelling(correctedText);
+      }
+
+      logger.debug('ASR corrections applied', {
+        originalLength: text.length,
+        correctedLength: correctedText.length,
+        config
+      });
+
+      return correctedText;
+
+    } catch (error) {
+      logger.warn('ASR corrections failed, returning original text', {
+        error: error instanceof Error ? error.message : String(error)
+      });
+      return text;
+    }
+  }
+
+  /**
+   * Apply static ASR corrections from centralized patterns
+   * Replaces: ASRCorrections.applyASRCorrections()
+   */
+  private applyStaticCorrections(text: string, categories: (keyof ASRCorrectionCategories)[] | 'all'): string {
+    let correctedText = text;
+    
+    const categoriesToApply = categories === 'all' 
+      ? Object.keys(ASRCorrections) as (keyof ASRCorrectionCategories)[]
+      : categories;
+
+    for (const category of categoriesToApply) {
+      const patterns = ASRCorrections[category];
+      for (const [pattern, replacement] of patterns) {
+        correctedText = correctedText.replace(pattern, replacement);
+      }
+    }
+
+    return correctedText;
+  }
+
+  /**
+   * Apply dynamic correction rules
+   * Replaces: DynamicASRCorrections.applyDynamicRules()
+   */
+  private applyDynamicRules(text: string, rules: Array<{ raw: string; fix: string }>): string {
+    let correctedText = text;
+    
+    for (const rule of rules) {
+      try {
+        const regex = new RegExp(`\\b${this.escapeRegExp(rule.raw)}\\b`, 'gi');
+        correctedText = correctedText.replace(regex, rule.fix);
+      } catch (error) {
+        logger.warn('Failed to apply dynamic rule', {
+          rule,
+          error: error instanceof Error ? error.message : String(error)
+        });
+      }
+    }
+    
+    return correctedText;
+  }
+
+  /**
+   * Apply custom correction rules for specific domains
+   */
+  private applyCustomRules(text: string, rules: CorrectionRule[]): string {
+    let correctedText = text;
+    
+    for (const rule of rules) {
+      try {
+        const regex = new RegExp(`\\b${this.escapeRegExp(rule.raw)}\\b`, 'gi');
+        correctedText = correctedText.replace(regex, rule.fix);
+      } catch (error) {
+        logger.warn('Failed to apply custom rule', {
+          rule,
+          error: error instanceof Error ? error.message : String(error)
+        });
+      }
+    }
+    
+    return correctedText;
+  }
+
+  /**
+   * Apply Australian spelling corrections
+   */
+  private applyAustralianSpelling(text: string): string {
+    const australianSpellings = {
+      'furosemide': 'frusemide',
+      'sulfasalazine': 'sulphasalazine', 
+      'sulfonylurea': 'sulphonylurea'
+    };
+
+    let correctedText = text;
+    for (const [us, au] of Object.entries(australianSpellings)) {
+      const usRegex = new RegExp(`\\b${us}\\b`, 'gi');
+      correctedText = correctedText.replace(usRegex, au);
+    }
+
+    return correctedText;
+  }
+
+  /**
+   * Domain-specific corrections for medical specialties
+   */
+  async applyMedicationCorrections(text: string): Promise<string> {
+    return this.applyCorrections(text, {
+      categories: ['medication'],
+      enableDynamic: true,
+      australianTerms: true,
+      medicalDomain: 'medication'
+    });
+  }
+
+  async applyPathologyCorrections(text: string): Promise<string> {
+    return this.applyCorrections(text, {
+      categories: ['pathology', 'laboratory'],
+      enableDynamic: true,
+      medicalDomain: 'pathology'
+    });
+  }
+
+  async applyCardiologyCorrections(text: string): Promise<string> {
+    return this.applyCorrections(text, {
+      categories: ['cardiology', 'severity', 'valves'],
+      enableDynamic: true,
+      medicalDomain: 'cardiology'
+    });
+  }
+
+  /**
+   * Get glossary terms for Whisper prompt seeding
+   * Replaces: DynamicASRCorrections.getGlossaryTerms()
+   */
+  async getGlossaryTerms(maxTerms: number = 50): Promise<string[]> {
+    try {
+      const dynamicCorrections = await this.getDynamicCorrections();
+      if (!dynamicCorrections) {
+        return [];
+      }
+
+      const terms = dynamicCorrections.glossaryTerms.slice(0, maxTerms);
+      
+      logger.debug('Retrieved glossary terms for Whisper prompt', {
+        totalTerms: dynamicCorrections.glossaryTerms.length,
+        returnedTerms: terms.length,
+        maxTerms
+      });
+
+      return terms;
+
+    } catch (error) {
+      logger.warn('Failed to get glossary terms', {
+        error: error instanceof Error ? error.message : String(error)
+      });
+      return [];
+    }
+  }
+
+  /**
+   * Register domain-specific custom rules
+   */
+  registerDomainRules(domain: string, rules: CorrectionRule[]): void {
+    this.customRules.set(domain, rules);
+    logger.info('Registered domain-specific ASR rules', {
+      domain,
+      ruleCount: rules.length
+    });
+  }
+
+  /**
+   * Add custom pattern for specific category
+   */
+  addCustomPattern(category: string, raw: string, fix: string, confidence: number = 1.0): void {
+    const rule: CorrectionRule = { raw, fix, category, confidence };
+    const existingRules = this.customRules.get(category) || [];
+    existingRules.push(rule);
+    this.customRules.set(category, existingRules);
+    
+    logger.debug('Added custom ASR pattern', { rule });
+  }
+
+  /**
+   * Get combined patterns from all categories
+   * Replaces: getCombinedPatterns()
+   */
+  getCombinedPatterns(categories: (keyof ASRCorrectionCategories)[] | 'all' = 'all'): ReplacementPattern[] {
+    return getCombinedPatterns(categories);
+  }
+
+  /**
+   * Get correction statistics
+   */
+  async getCorrectionStats(): Promise<CorrectionStats> {
+    const staticPatterns = getCombinedPatterns('all').length;
+    const dynamicCorrections = await this.getDynamicCorrections();
+    
+    let customRulesCount = 0;
+    for (const rules of this.customRules.values()) {
+      customRulesCount += rules.length;
+    }
+    
+    return {
+      staticPatterns,
+      dynamicRules: dynamicCorrections?.correctionRules.length || 0,
+      customRules: customRulesCount,
+      lastUpdated: dynamicCorrections ? new Date(dynamicCorrections.lastUpdated) : null,
+      cacheValid: this.isCacheValid()
+    };
+  }
+
+  // Private helper methods
+
+  private async getDynamicCorrections() {
+    if (this.dynamicCorrections && this.isCacheValid()) {
+      return this.dynamicCorrections;
+    }
+
+    try {
+      const asrState = await this.optimizationService.getCurrentASRState();
+      
+      this.dynamicCorrections = {
+        glossaryTerms: asrState.glossary,
+        correctionRules: asrState.rules,
+        lastUpdated: Date.now()
+      };
+
+      return this.dynamicCorrections;
+    } catch (error) {
+      logger.warn('Failed to load dynamic corrections', {
+        error: error instanceof Error ? error.message : String(error)
+      });
+      return null;
+    }
+  }
+
+  private isCacheValid(): boolean {
+    return this.dynamicCorrections 
+      ? (Date.now() - this.dynamicCorrections.lastUpdated) < this.CACHE_TTL
+      : false;
+  }
+
+  private escapeRegExp(string: string): string {
+    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
+  }
+}
+
+// Convenience functions for backward compatibility
+export async function applyASRCorrections(
+  text: string, 
+  categories: (keyof ASRCorrectionCategories)[] | 'all' = 'all'
+): Promise<string> {
+  return ASRCorrectionEngine.getInstance().applyCorrections(text, { categories });
+}
+
+export async function applyEnhancedASRCorrections(
+  text: string,
+  categories: (keyof ASRCorrectionCategories)[] | 'all' = 'all'
+): Promise<string> {
+  return ASRCorrectionEngine.getInstance().applyCorrections(text, { 
+    categories, 
+    enableDynamic: true,
+    australianTerms: true
+  });
+}

--- a/src/agents/specialized/BloodsAgent.ts
+++ b/src/agents/specialized/BloodsAgent.ts
@@ -8,7 +8,7 @@ import { BLOODS_SYSTEM_PROMPTS, BLOODS_MEDICAL_PATTERNS } from './BloodsSystemP
 import { LMStudioService, MODEL_CONFIG } from '@/services/LMStudioService';
-import { applyASRCorrections } from '@/utils/ASRCorrections';
+import { ASRCorrectionEngine } from '@/utils/asr/ASRCorrectionEngine';
 import type { 
   MedicalReport, 
   ReportSection, 
@@ -19,6 +19,7 @@ import type {
 export class BloodsAgent extends MedicalAgent {
   private lmStudioService: LMStudioService;
+  private asrEngine: ASRCorrectionEngine;
 
   constructor() {
     super(
@@ -29,6 +30,7 @@ export class BloodsAgent extends MedicalAgent {
       BLOODS_SYSTEM_PROMPTS.primary
     );
     
     this.lmStudioService = LMStudioService.getInstance();
+    this.asrEngine = ASRCorrectionEngine.getInstance();
   }
 
   async process(input: string, context?: MedicalContext): Promise<MedicalReport> {
@@ -37,7 +39,7 @@ export class BloodsAgent extends MedicalAgent {
 
     try {
       // Apply ASR corrections for common pathology terms
-      const correctedInput = this.applyBloodsASRCorrections(input);
+      const correctedInput = await this.asrEngine.applyPathologyCorrections(input);
       console.log('ðŸ”„ Applied bloods ASR corrections:', correctedInput);
 
       // Build messages for AI processing
@@ -80,45 +82,6 @@ export class BloodsAgent extends MedicalAgent {
     }
   }
 
-  /**
-   * Apply blood test specific ASR corrections
-   * Common transcription errors for pathology orders
-   */
-  private applyBloodsASRCorrections(input: string): string {
-    let corrected = input;
-    
-    // Apply standard pathology corrections
-    corrected = applyASRCorrections(corrected, ['pathology', 'laboratory']);
-    
-    // Blood test specific corrections
-    const bloodsCorrections = [
-      // Common blood test mishearings
-      [/\bUNE\b/g, 'EUC'],  // UNE -> EUC
-      [/\bUNEs\b/g, 'EUC'],
-      [/\byou and ease\b/gi, 'EUC'],
-      [/\byou and E's\b/gi, 'EUC'],
-      [/\bU and E's\b/gi, 'EUC'],
-      
-      // Full blood count variations
-      [/\bFBE\b/g, 'FBC'],
-      [/\bfull blood examination\b/gi, 'FBC'],
-      
-      // Liver function tests
-      [/\bLFTs\b/g, 'LFT'],
-      [/\bliver function tests\b/gi, 'LFT'],
-      
-      // Common abbreviations
-      [/\bTFTs\b/g, 'TFT'],
-      [/\bCRPs\b/g, 'CRP'],
-      [/\bESRs\b/g, 'ESR']
-    ];
-    
-    for (const [pattern, replacement] of bloodsCorrections) {
-      corrected = corrected.replace(pattern, replacement);
-    }
-    
-    return corrected;
-  }
-
   protected buildMessages(input: string, context?: MedicalContext): ChatMessage[] {
     return [
       {

--- a/src/utils/DynamicASRCorrections.ts
+++ b/src/utils/DynamicASRCorrections.ts
@@ -1,535 +1,15 @@
 /**
- * Dynamic ASR Corrections - Runtime Merge Logic
- * 
- * Merges static ASR corrections from ASRCorrections.ts with dynamic corrections
- * from the optimization system. Provides unified correction application.
- * 
- * Features:
- * - Runtime loading of dynamic corrections from DSPy server
- * - Merge static + dynamic patterns with conflict resolution
- * - Caching for performance optimization
- * - Fallback to static-only mode if dynamic corrections unavailable
+ * Legacy Dynamic ASR Corrections - DEPRECATED
+ * This file is kept for backward compatibility during migration
+ * Please use ASRCorrectionEngine from @utils/asr/ASRCorrectionEngine instead
  */
 
-import { logger } from '@/utils/Logger';
-import { 
-  applyASRCorrections, 
-  getCombinedPatterns, 
-  type ReplacementPattern,
-  type ASRCorrectionCategories 
-} from './ASRCorrections';
-import { OptimizationService } from '@/services/OptimizationService';
-import type { ASRCurrentState } from '@/types/optimization';
+import { ASRCorrectionEngine, applyEnhancedASRCorrections } from './asr/ASRCorrectionEngine';
+import type { ASRCorrectionCategories } from './ASRCorrections';
 
-interface DynamicCorrections {
-  glossaryTerms: string[];
-  correctionRules: Array<{ raw: string; fix: string }>;
-  lastUpdated: number;
-}
-
-interface MergedCorrections {
-  staticPatterns: ReplacementPattern[];
-  dynamicPatterns: ReplacementPattern[];
-  glossaryTerms: string[];
-  lastMerged: number;
-}
-
-export class DynamicASRCorrections {
-  private static instance: DynamicASRCorrections;
-  private optimizationService: OptimizationService;
-  
-  // Cache for dynamic corrections
-  private dynamicCorrections: DynamicCorrections | null = null;
-  private mergedCorrections: MergedCorrections | null = null;
-  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
-  private isLoadingDynamic = false;
-
-  private constructor() {
-    this.optimizationService = OptimizationService.getInstance();
-    logger.info('DynamicASRCorrections initialized', { 
-      component: 'DynamicASRCorrections'
-    });
-  }
-
-  public static getInstance(): DynamicASRCorrections {
-    if (!DynamicASRCorrections.instance) {
-      DynamicASRCorrections.instance = new DynamicASRCorrections();
-    }
-    return DynamicASRCorrections.instance;
-  }
-
-  /**
-   * Apply both static and dynamic ASR corrections to text
-   */
-  async applyEnhancedCorrections(
-    text: string, 
-    categories: (keyof ASRCorrectionCategories)[] | 'all' = 'all'
-  ): Promise<string> {
-    try {
-      // First apply static corrections
-      let correctedText = applyASRCorrections(text, categories);
-
-      // Then apply dynamic corrections
-      const dynamicCorrections = await this.getDynamicCorrections();
-      if (dynamicCorrections && dynamicCorrections.correctionRules.length > 0) {
-        correctedText = this.applyDynamicRules(correctedText, dynamicCorrections.correctionRules);
-      }
-
-      return correctedText;
-
-    } catch (error) {
-      logger.warn('Enhanced ASR corrections failed, falling back to static only', {
-        component: 'DynamicASRCorrections',
-        error: error.message
-      });
-      
-      // Fallback to static corrections only
-      return applyASRCorrections(text, categories);
-    }
-  }
-
-  // ... rest of the implementation removed for brevity
-  // This would contain 500+ lines of duplicate logic now handled by ASRCorrectionEngine
-}
-
-/**
- * Convenience function for applying enhanced ASR corrections
- */
+// Legacy function - redirects to new implementation
 export async function applyEnhancedASRCorrections(
   text: string,
   categories: (keyof ASRCorrectionCategories)[] | 'all' = 'all'
 ): Promise<string> {
-  const dynamicASR = DynamicASRCorrections.getInstance();
-  return await dynamicASR.applyEnhancedCorrections(text, categories);
+  return ASRCorrectionEngine.getInstance().applyCorrections(text, { categories, enableDynamic: true });
 }
-
-/**
- * Get glossary terms for Whisper prompt seeding
- */
-export async function getWhisperGlossaryTerms(maxTerms: number = 50): Promise<string[]> {
-  const dynamicASR = DynamicASRCorrections.getInstance();
-  return await dynamicASR.getGlossaryTerms(maxTerms);
-}