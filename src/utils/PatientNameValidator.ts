/**
 * Patient Name Validation Utility
 *
 * Validates and compares patient names between sessions and EMR records
 * to prevent accidental insertion into wrong patient files.
 */

import { logger } from '@/utils/Logger';

export interface PatientNameComparison {
  sessionPatientName: string;
  emrPatientName: string;
  similarityScore: number;
  isMatch: boolean;
  confidence: 'high' | 'medium' | 'low';
  normalizedSessionName: string;
  normalizedEmrName: string;
  warnings: string[];
}

export interface ValidationConfig {
  minSimilarityScore: number; // 0-1, default 0.8
  caseSensitive: boolean;
  ignoreTitles: boolean;
  allowPartialMatches: boolean;
  enabled: boolean;
}

export class PatientNameValidator {
  private static instance: PatientNameValidator;
  private config: ValidationConfig = {
    minSimilarityScore: 0.8,
    caseSensitive: false,
    ignoreTitles: true,
    allowPartialMatches: true,
    enabled: true
  };

  private constructor() {
    logger.debug('PatientNameValidator initialized');
  }

  public static getInstance(): PatientNameValidator {
    if (!PatientNameValidator.instance) {
      PatientNameValidator.instance = new PatientNameValidator();
    }
    return PatientNameValidator.instance;
  }

  /**
   * Updates the validation configuration
   */
  public updateConfig(newConfig: Partial<ValidationConfig>): void {
    this.config = { ...this.config, ...newConfig };
    logger.debug('PatientNameValidator config updated:', this.config);
  }

  /**
   * Main validation method - compares session patient name with EMR patient name
   */
  public validatePatientNames(sessionPatientName: string, emrPatientName: string): PatientNameComparison {
    const warnings: string[] = [];

    // Skip validation if disabled
    if (!this.config.enabled) {
      return {
        sessionPatientName,
        emrPatientName,
        similarityScore: 1.0,
        isMatch: true,
        confidence: 'high',
        normalizedSessionName: sessionPatientName,
        normalizedEmrName: emrPatientName,
        warnings: ['Validation disabled']
      };
    }

    // Check for empty or fallback names
    if (!sessionPatientName || !emrPatientName) {
      warnings.push('Missing patient name data');
      return {
        sessionPatientName: sessionPatientName || 'Unknown',
        emrPatientName: emrPatientName || 'Unknown',
        similarityScore: 0,
        isMatch: false,
        confidence: 'low',
        normalizedSessionName: '',
        normalizedEmrName: '',
        warnings
      };
    }

    // Check for fallback patient names (generated by system)
    if (this.isFallbackPatientName(sessionPatientName) || this.isFallbackPatientName(emrPatientName)) {
      warnings.push('Fallback patient name detected - validation may be unreliable');
    }

    // Normalize names for comparison
    const normalizedSessionName = this.normalizeName(sessionPatientName);
    const normalizedEmrName = this.normalizeName(emrPatientName);

    // Calculate similarity
    const similarityScore = this.calculateSimilarity(normalizedSessionName, normalizedEmrName);
    const isMatch = similarityScore >= this.config.minSimilarityScore;

    // Determine confidence level
    let confidence: 'high' | 'medium' | 'low';
    if (similarityScore >= 0.95) confidence = 'high';
    else if (similarityScore >= 0.75) confidence = 'medium';
    else confidence = 'low';

    // Add warnings based on similarity
    if (!isMatch) {
      if (similarityScore > 0.5) {
        warnings.push('Names are similar but not identical - possible transcription variation');
      } else {
        warnings.push('Names appear to be completely different');
      }
    }

    const result: PatientNameComparison = {
      sessionPatientName,
      emrPatientName,
      similarityScore,
      isMatch,
      confidence,
      normalizedSessionName,
      normalizedEmrName,
      warnings
    };

    logger.debug('Patient name validation result:', result);
    return result;
  }

  /**
   * Normalizes a patient name for comparison
   */
  private normalizeName(name: string): string {
    if (!name) return '';

    let normalized = name.trim();

    // Remove titles if configured
    if (this.config.ignoreTitles) {
      normalized = normalized.replace(/^(Mr\.?|Mrs\.?|Ms\.?|Dr\.?|Miss)\s+/i, '');
    }

    // Remove common suffixes and IDs
    normalized = normalized.replace(/\s*\(\d+\)$/, ''); // Remove (ID) pattern
    normalized = normalized.replace(/\s*\(Session-\d+\)$/, ''); // Remove fallback session IDs

    // Normalize whitespace
    normalized = normalized.replace(/\s+/g, ' ').trim();

    // Handle case sensitivity
    if (!this.config.caseSensitive) {
      normalized = normalized.toLowerCase();
    }

    return normalized;
  }

  /**
   * Calculates similarity between two normalized names using Levenshtein distance
   */
  private calculateSimilarity(name1: string, name2: string): number {
    if (!name1 || !name2) return 0;
    if (name1 === name2) return 1;

    // If partial matches allowed, check if one name contains the other
    if (this.config.allowPartialMatches) {
      const longer = name1.length > name2.length ? name1 : name2;
      const shorter = name1.length > name2.length ? name2 : name1;

      if (longer.includes(shorter) && shorter.length >= 3) {
        return 0.85; // High similarity for partial matches
      }
    }

    // Calculate Levenshtein distance
    const distance = this.levenshteinDistance(name1, name2);
    const maxLength = Math.max(name1.length, name2.length);

    if (maxLength === 0) return 1;

    return 1 - (distance / maxLength);
  }

  /**
   * Calculates Levenshtein distance between two strings
   */
  private levenshteinDistance(str1: string, str2: string): number {
    const matrix: number[][] = [];

    // Initialize matrix
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }

    // Fill matrix
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1, // substitution
            matrix[i][j - 1] + 1,     // insertion
            matrix[i - 1][j] + 1      // deletion
          );
        }
      }
    }

    return matrix[str2.length][str1.length];
  }

  /**
   * Checks if a patient name appears to be a system-generated fallback
   */
  private isFallbackPatientName(name: string): boolean {
    if (!name) return true;

    const fallbackPatterns = [
      /^Patient \d+/i,                    // "Patient 1", "Patient 2"
      /^Patient \d+ \(\d{1,2}:\d{2}\)$/i, // "Patient 1 (14:30)"
      /^Session-\d+$/i,                   // "Session-123456"
      /^Unknown$/i,                       // "Unknown"
      /^Patient$/i                        // "Patient"
    ];

    return fallbackPatterns.some(pattern => pattern.test(name.trim()));
  }

  /**
   * Gets a user-friendly explanation of the validation result
   */
  public getValidationExplanation(comparison: PatientNameComparison): string {
    if (!this.config.enabled) {
      return 'Patient name validation is disabled.';
    }

    if (comparison.isMatch) {
      return `Patient names match with ${Math.round(comparison.similarityScore * 100)}% confidence.`;
    }

    if (comparison.similarityScore > 0.5) {
      return `Patient names are similar (${Math.round(comparison.similarityScore * 100)}% match) but may represent different patients or transcription variations.`;
    }

    return `Patient names appear to be different (${Math.round(comparison.similarityScore * 100)}% match). You may be inserting into the wrong patient file.`;
  }

  /**
   * Determines if validation should be skipped for these names
   */
  public shouldSkipValidation(sessionPatientName: string, emrPatientName: string): boolean {
    // Skip if validation is disabled
    if (!this.config.enabled) return true;

    // Skip if both names are fallback names (nothing meaningful to compare)
    if (this.isFallbackPatientName(sessionPatientName) && this.isFallbackPatientName(emrPatientName)) {
      logger.debug('Skipping validation - both names are fallback names');
      return true;
    }

    // Skip if either name is too short to be meaningful
    const minNameLength = 3;
    if (sessionPatientName.trim().length < minNameLength || emrPatientName.trim().length < minNameLength) {
      logger.debug('Skipping validation - names too short to validate');
      return true;
    }

    return false;
  }
}

// Export singleton instance for easy usage
export const patientNameValidator = PatientNameValidator.getInstance();